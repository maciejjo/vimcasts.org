<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title></title>

    <link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/all.js" type="text/javascript"></script>
  </head>

  <body>
    <div id="logo">
      <h1>
        
          <a href="/" title="Go to Vimcasts.org homepage">VimCasts.org</a>
        
      </h1>
    </div>
    <p>In the previous episode, we saw how to use the quoteplus register to paste text from the system clipboard. Unfortunately, we can't always expect the clipboard feature to be supported. In particular, if we're running an instance of Vim on a remote machine, there's no simple way of accessing the clipboard from our local workstation.</p>

<p>We can use the system paste command: control-v, or command-v on a mac, but this has some issues. Watch what happens if I copy this snippet of javascript, then use the system paste command in Insert mode: the indentation goes haywire!</p>

<p>The problem is that when Vim runs inside a terminal, it can't distinguish between characters that are typed manually and those that are pasted. In this case, each time Vim creates a newline, it's autoindented. Add on top of that the indentation that was already present the source code, and we end up with each line drifting farther and farther to the right.</p>

<p>We can avoid this by enabling the <code>paste</code> option, which temporarily disables several options that can interfere when pasting text. Watch:</p>

<pre><code>:set paste
</code></pre>

<p>I'll switch to Insert mode. Note that Vim tells us the paste option is enabled. Now when I use the system paste command it behaves fine!</p>

<p>You might be wondering: Why not keep the <code>paste</code> option enabled at all times? Well, there's a gotcha! When the paste option is enabled, any abbreviations or mappings defined for Insert mode will be disabled. To demonstrate, I'll map <code>kj</code> to Escape in Insert mode:</p>

<pre><code>:inoremap kj &lt;Esc&gt;
</code></pre>

<p>If I try using that mapping in Insert mode, it just inserts the characters <code>kj</code>. But if I disable the <code>paste</code> option:</p>

<pre><code>:set nopaste
</code></pre>

<p>and switch back to Insert mode, pressing <code>kj</code> now maps to the Escape key, putting me back into Normal mode.</p>

<p>So remember: with the <code>paste</code> option enabled, you're safe to use the system paste command, but any user-defined Insert mode mappings will fail. For that reason, it's a good idea to turn off the <code>paste</code> option as soon as you're finished using it.</p>

<p>If you're thinking of creating a mapping to make it easier to toggle the paste option, don't forget that your mapping won't work in Insert mode! Read Vim's documentation on <code>'pastetoggle'</code> to learn about a workaround.</p>

<h3 id="unimpaired-mapping">Unimpaired mapping</h3>

<p>I like the solution Tim Pope has come up with in his unimpaired plugin. He notes that:</p>

<blockquote>
  <p>you toggle twice, but only paste once.
:h yp</p>
</blockquote>

<p>Which is wasteful.</p>

<p>Watch this:</p>

<pre><code>:set paste?
nopaste
</code></pre>

<p>The paste option is currently disabled. I'll switch to Insert mode by pressing <code>yo</code>, which is a mapping provided by unimpaired. Just like the regular <code>o</code> command, it opens a new line and switches to Insert mode, but this variant also enables the <code>paste</code> option. I can safely use the system paste command. And when I return to Normal mode, an autocommand disables the paste option for me:</p>

<pre><code>:set paste?
nopaste
</code></pre>

<p>That's a much neater workflow than having to toggle the <code>paste</code> option on and off again manually.</p>

  </body>

</html>
